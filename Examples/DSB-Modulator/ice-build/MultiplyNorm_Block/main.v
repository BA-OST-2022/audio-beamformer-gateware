// Code generated by Icestudio 0.9.0

`default_nettype none

//---- Top entity
module main (
 input [15:0] ve5e35f,
 input [15:0] v7562a5,
 input v065c9e,
 input v907022,
 output [15:0] v42a45c,
 output [0:7] vinit
);
 wire [0:31] w0;
 wire [0:15] w1;
 wire [0:15] w2;
 wire w3;
 wire w4;
 wire [0:15] w5;
 assign w1 = ve5e35f;
 assign w2 = v7562a5;
 assign w3 = v065c9e;
 assign w4 = v907022;
 assign v42a45c = w5;
 v6a1dec vd938b6 (
  .va66a4c(w0),
  .vfa2ff3(w1),
  .v7a25d5(w2),
  .v6ef738(w3),
  .vb58dd5(w4)
 );
 main_v7818e5 v7818e5 (
  .in(w0),
  .out(w5)
 );
 main_v8c49f3 v8c49f3 (
 
 );
 assign vinit = 8'b00000000;
endmodule

//---- Top entity
module v6a1dec (
 input vb58dd5,
 input v6ef738,
 input [15:0] vfa2ff3,
 input [15:0] v7a25d5,
 output v867092,
 output v33b195,
 output [31:0] va66a4c
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire [0:31] w4;
 wire [0:15] w5;
 wire [0:15] w6;
 assign w0 = v6ef738;
 assign w1 = vb58dd5;
 assign v33b195 = w2;
 assign v867092 = w3;
 assign va66a4c = w4;
 assign w5 = vfa2ff3;
 assign w6 = v7a25d5;
 v6a1dec_v6f8349 v6f8349 (
  .start(w0),
  .clk(w1),
  .busy(w2),
  .pulse_done(w3),
  .y(w4),
  .a(w5),
  .b(w6)
 );
endmodule

//---------------------------------------------------
//-- mul_int16_32
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- 16 bit inputs signed integer multiplier, 32 bits output
//---------------------------------------------------

module v6a1dec_v6f8349 (
 input clk,
 input start,
 input [15:0] a,
 input [15:0] b,
 output pulse_done,
 output busy,
 output [31:0] y
);
 // y = a * b, signed integers
 
 localparam N = 16;
 
 reg [(N+N-1):0] y = 0;
 reg out_valid;
 reg ready = 1;
 reg pulse_done = 0;
 reg busy = 0;
 
 reg [N-1:0] A;
 reg [N-1:0] B;
 reg [$clog2(N+1)-1:0] state = 0;
 reg [N-1:0] work;   
 reg [N-2:0] resultLsb;
 
 wire [N-1:0] pp = {N{A[0]}} & B;
 wire [N-1:0] pMod1 = {~pp[N-1], pp[N-2:0]};
 wire [N-1:0] pMod2 = ~pMod1;
 wire [N:0] sum12 = work + ((state == N) ? pMod2 : pMod1);
 wire [N:0] sum1 = sum12;
 wire [N:0] sum2 = sum12;
    
 reg prev_start = 0;   
    
 always @(posedge clk) 
 begin
     out_valid <= 0;
     A <= {1'bx, A[N-1:1]};      
     case (state)
 	    0:
 	        begin 
 	            pulse_done <= 0;
 	            busy <= 0;
 	        end
 	    1:  begin
 	            work <= {1'b1, pMod1[N-1:1]};
 	            resultLsb <= {pMod1[0], {N-2{1'bx}}};
 	            state <= state + 1;
 	        end
 	    default: 
 	        begin
 	            work <= sum1[N:1];
 	            resultLsb <= {sum1[0], resultLsb[N-2:1]};	   
 	            state <= state + 1;
 	        end
 	    N: 
 	        begin
 	            y <= {~sum2[N], sum2[N-1:0], resultLsb};
 	            out_valid <= 1;
 	            pulse_done <= 1;
 	            work <= 'bx;
 	            state <= 0;
 	            resultLsb <= 'bx;
 	            B <= 'bx;
 	            ready <= 1;	    
 	        end
     endcase
       
     if (start && !prev_start) 
     begin
 	    A <= a;
 	    B <= b;
 	    state <= 1;
 	    ready <= 0;
 	    busy <= 1;
     end
     
     prev_start <= start;
 end
endmodule

module main_v7818e5 (
 input [31:0] in,
 output [15:0] out
);
 reg signed [31:0] data;
 assign data = in;
 assign out = data >>> 16;
endmodule

module main_v8c49f3 (
 input [15:0] a,
 input [15:0] b,
 input clk_in,
 output [31:0] y
);
 reg signed [15:0] a_int;
 reg signed [15:0] b_int;
 reg signed [32:0] w_int;
 reg signed [32:0] y_int;
 
 assign a_int = a;
 assign b_int = b;
 assign y = y_int;
 
 always @(posedge clk_in) begin
   w_int <= a_int * b_int;
   y_int <= w_int;
 end
endmodule
